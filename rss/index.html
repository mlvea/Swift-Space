<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="https://purl.org/dc/elements/1.1/" xmlns:content="https://purl.org/rss/1.0/modules/content/" xmlns:atom="https://www.w3.org/2005/Atom" version="2.0" xmlns:media="https://search.yahoo.com/mrss/"><channel><title><![CDATA[Swift - The Programming Language]]></title><description><![CDATA[Swift - The Programming Language]]></description><link>https://swift.madnik.space/</link><generator>Ghost 0.8</generator><lastBuildDate>Fri, 22 Jul 2016 06:55:23 GMT</lastBuildDate><atom:link href="https://swift.madnik.space/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Algorithms - Merge Sort and Quick Sort in swift]]></title><description><![CDATA[<p>Quick sort and Merge sort both are divide and conquer algorithms</p>

<h3 id="divideandconquer">Divide and Conquer</h3>

<p>Divide and Conquer is a algorithm paradigm based on recursion. </p>

<h5 id="divide">Divide</h5>

<p>Break the problem into sub problems that are similar to original problem. Then solve subproblems recursively.</p>

<h5 id="conquer">Conquer</h5>

<p>Finally combine the solutions to subproblems to solve</p>]]></description><link>https://swift.madnik.space/algorithms-merge-sort-and-quick-sort-in-swift/</link><guid isPermaLink="false">15ef3c25-1ca2-4295-b3aa-47d631bf4d8c</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Fri, 22 Jul 2016 06:51:37 GMT</pubDate><content:encoded><![CDATA[<p>Quick sort and Merge sort both are divide and conquer algorithms</p>

<h3 id="divideandconquer">Divide and Conquer</h3>

<p>Divide and Conquer is a algorithm paradigm based on recursion. </p>

<h5 id="divide">Divide</h5>

<p>Break the problem into sub problems that are similar to original problem. Then solve subproblems recursively.</p>

<h5 id="conquer">Conquer</h5>

<p>Finally combine the solutions to subproblems to solve the original problem.</p>

<hr>

<h3 id="mergesort">Merge Sort</h3>

<p>If you want a sound explanation about the algorithm please refer. <br>
<a href="https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/overview-of-merge-sort">In detail explanation by khan Academy</a></p>

<pre><code class="language-swift">func mergeSort&lt;T: Comparable&gt;(inout array:[T],p: Int, r: Int) -&gt; [T]{

    var p = p

    guard r &gt; p else{
        return array
    }

    var q = p + (r-p)/2

    mergeSort(&amp;array, p: p, r: q)
    mergeSort(&amp;array, p: q+1, r: r)

    //Now merge.
    while q &lt; r &amp;&amp; p &lt;= q {

        if array[p] &gt; array[q+1]{
            array.insert(array.removeAtIndex(q+1), atIndex: p)
            if q &lt; r { q+=1 }
        }
        if p &lt;= q { p += 1 }
    }

    return array
}
</code></pre>

<hr>

<h3 id="quicksort">Quick Sort</h3>

<p>Again for detail explanation please refer. <br>
<a href="https://www.khanacademy.org/computing/computer-science/algorithms/quick-sort/a/overview-of-quicksort">Quick Sort explanation by Khan Academy</a></p>

<p>Quick sort can be implemented very easily using swift filter.  </p>

<pre><code class="language-swift">func quickSortEasy&lt;T where T:Comparable&gt;(array: [T]) -&gt; [T]{  
    guard array.count &gt; 1 else{
        return array
    }

    let pivot = array[array.count/2]

    let lessThanPivot = array.filter{ $0 &lt; pivot }
    let equalToPivot = array.filter{ $0 == pivot }
    let greaterThanPivot = array.filter{ $0 &gt; pivot }

    return quickSortEasy(lessThanPivot) + equalToPivot + quickSortEasy(greaterThanPivot)
}
</code></pre>

<p>But this is not the best way to do it. It create intermediate arrays within sub problems.</p>

<p>We can do better than this.</p>

<pre><code class="language-swift">func quickSort&lt;T where T:Comparable&gt;(inout array: [T],p: Int,r: Int) -&gt; [T]{

    guard array[p...r].count &gt; 1 else{
        return array
    }

    func partition&lt;T where T:Comparable&gt;(inout array: [T],pivotIndex: Int) -&gt; Int{
        var q = p
        var i = p

        let pivot = array[pivotIndex]

        while i &lt; r{
            if array[i] &lt; pivot {
                array.insert(array.removeAtIndex(i), atIndex: q)
                q += 1
            }

            i += 1
        }
        array.insert(array.removeAtIndex(pivotIndex), atIndex: q)
        return q
    }

    let q = partition(&amp;array, pivotIndex: r)
    if p &lt; q-1 { quickSort(&amp;array, p: p, r: q-1) }
    if q+1 &lt; r { quickSort(&amp;array, p: q+1, r: r) }

    return array
}
</code></pre>]]></content:encoded></item><item><title><![CDATA[ThinkTank 01]]></title><description><![CDATA[Overriding declaration requires an 'override' keyword]]></description><link>https://swift.madnik.space/thinktank-01-2/</link><guid isPermaLink="false">56092533-46ad-46c7-b1d2-a8dd6c57e35a</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Thu, 21 Jul 2016 11:16:35 GMT</pubDate><content:encoded><![CDATA[<h2 id="simpleyetimportantfactsaboutswiftintheformofquestions">Simple yet important facts about swift in the form of questions.</h2>

<h4 id="firstonewhythecompileerror">First One. Why the compile error?</h4>

<pre><code class="language-swift">class A{

}

class B: A{  
    var i: Int

    //Compile Error: Overriding declaration requires an 'override' keyword
    init() {
        i = 4
    }
}
</code></pre>

<p>How come <code>init()</code> becomes an Overriding declaration?</p>

<h4 id="because">Because</h4>

<blockquote>
  <p>Swift provides default initializer for any class or structure that provides initail values for all of its properties and that does not provide at least one initializer itself.</p>
</blockquote>

<p>The class <code>A</code> has no stored properties. So we can simply assume all properties are initialized. It doesn't provide a initializer either. So it qualifies for a default initializer. Indeed there is one. In the form of <code>init()</code>.</p>

<p>So the correct syntax for class <code>B</code> should be.</p>

<pre><code class="language-swift">class B: A{  
    var i: Int    

    override init() {
        i = 4
    }
}
</code></pre>

<p>What if class <code>A</code> does have an initializer.</p>

<pre><code class="language-swift">class A{  
    var j: Int
    init(j: Int){
        self.j = j
    }
}
</code></pre>

<p>In this case class <code>A</code> doesn't receive a default initializer. </p>

<p>class <code>B</code> initializer should omit <code>override</code> keyword.  </p>

<pre><code class="language-swift">class B: A{  
    var i: Int

    init() {
        i = 4
        super.init(j: 5)
    }
}
</code></pre>

<hr>

<h4 id="secondoneisthisvalid">Second One. Is this valid?</h4>

<p>If we declare class <code>B</code> as follows. Is it valid?</p>

<pre><code class="language-swift">class B: A{  
    var i: Int

    init() {
        self.i = 4
        self.j = 9
        super.init(j: 5)

    }
}
</code></pre>

<p>The answer is.</p>

<p>.</p>

<p>.</p>

<p>.</p>

<p>.</p>

<h4 id="no">No.</h4>

<p>The compiler screams.  </p>

<blockquote>
  <p>Use of self in property access <code>j</code> before <code>super.init</code> initializes self.</p>
</blockquote>

<p>The reason is part of swift two-phase initialization process.</p>

<p>Compiler safety check 2 is in action.</p>

<h4 id="safetycheck2">Safety check 2</h4>

<p>A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesnâ€™t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.</p>

<p>So the correct declaration should be.</p>

<pre><code class="language-swift">class B: A{  
    var i: Int

    init() {
        self.i = 4
        super.init(j: 5)
        self.j = 9
    }
}
</code></pre>]]></content:encoded></item><item><title><![CDATA[Indirect Enums and Indirect Enum cases - Recursive enum Enum is not marked as indirect]]></title><description><![CDATA[<blockquote>
  <p>Recursive enum <code>AEnum</code> is not marked as <code>indirect</code></p>
</blockquote>

<p>Have encountered this error? <br>
What is this <code>indirect</code> keyword. Why we need it.</p>

<p>indirection of Enums introduced in Swift 2 in order to solve major problem when a Enum needed to be recursive.</p>

<h3 id="theproblem">The Problem</h3>

<p>Consider the following Enum definition. A very</p>]]></description><link>https://swift.madnik.space/indirect-enums-and-indirect-enum-cases-recursive-enum-enum-is-not-marked-as-indirect/</link><guid isPermaLink="false">acf8676c-73d9-4412-898d-17836b2b9d3e</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Mon, 04 Jul 2016 09:37:14 GMT</pubDate><content:encoded><![CDATA[<blockquote>
  <p>Recursive enum <code>AEnum</code> is not marked as <code>indirect</code></p>
</blockquote>

<p>Have encountered this error? <br>
What is this <code>indirect</code> keyword. Why we need it.</p>

<p>indirection of Enums introduced in Swift 2 in order to solve major problem when a Enum needed to be recursive.</p>

<h3 id="theproblem">The Problem</h3>

<p>Consider the following Enum definition. A very same example used to introduce indirection at apple presentation.</p>

<pre><code class="language-swift">enum Tree&lt;T&gt; {  
  case Leaf(T)
  case Node(Tree, Tree) 
}
</code></pre>

<p>Swift Enum is a value types. So the associated values in an enum stored inline. This can make the above <code>Tree</code> enum (A recursive enum as you can see) can possibly take infinite size.</p>

<h3 id="solution">Solution</h3>

<p>Lets look at the possible workaround used before they introduced Swift 2.0.  </p>

<h4 id="01priortoindirect">01 Prior to <code>indirect</code></h4>

<pre><code class="language-swift">final class Box&lt;T&gt; {  
    let unbox: T
    init(_ x: T) { self.unbox = x }
}

enum Tree&lt;T&gt;{  
    case Leaf(Box&lt;Tree&lt;T&gt;&gt;)
    case Node(Box&lt;Tree&lt;T&gt;&gt;,Box&lt;Tree&lt;T&gt;&gt;)
}
</code></pre>

<p>Now. We have made the associated values a reference type indirectly.</p>

<p>However this solution is ugly and this breaks the great pattern matching of Enum.</p>

<h4 id="02useindirect">02 Use <code>indirect</code></h4>

<p>Swift 2 made this painless. No more boxing.</p>

<pre><code class="language-swift">enum Tree&lt;T&gt; {  
    indirect case Leaf(T)
    indirect case Node(Tree, Tree)
}
</code></pre>

<p>Or you can mark the entire enum as <code>indirect</code> which simply ask compiler to use indirection wherever applicable.</p>

<pre><code class="language-swift">indirect enum Tree&lt;T&gt; {  
   case Leaf(T)
   case Node(Tree, Tree)
}
</code></pre>

<p>This is great addition to enum which make the algebraic data type lot more powerful.</p>

<blockquote>
  <p>Think? Why doesn't the compiler infer the indirection for us automatically.</p>
</blockquote>

<p>Here is <a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151207/000259.html">some discussion</a> on why?</p>]]></content:encoded></item><item><title><![CDATA[Protocol Extensions to Rescue - reuseIdentifier]]></title><description><![CDATA[<p>This post is one of the chain posts that discuss the use cases of swift protocol extensions. </p>

<p>Recently <a href="https://twitter.com/natashatherobot">natashatherobot</a> discussed this topic in one of her <a href="https://realm.io/news/appbuilders-natasha-muraschev-practical-protocol-oriented-programming/">talk</a>. </p>

<p>reuseIdentifier - not a new term for iOS developers. We always meet this at <code>UITableViewCell</code>. reuseIdentifier is part of the cell reusing mechanism</p>]]></description><link>https://swift.madnik.space/protocol-extensions-to-rescue-reuseidentifier/</link><guid isPermaLink="false">ac1eb75c-7aaf-4324-94a5-f0f861cd8467</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Wed, 29 Jun 2016 14:11:06 GMT</pubDate><content:encoded><![CDATA[<p>This post is one of the chain posts that discuss the use cases of swift protocol extensions. </p>

<p>Recently <a href="https://twitter.com/natashatherobot">natashatherobot</a> discussed this topic in one of her <a href="https://realm.io/news/appbuilders-natasha-muraschev-practical-protocol-oriented-programming/">talk</a>. </p>

<p>reuseIdentifier - not a new term for iOS developers. We always meet this at <code>UITableViewCell</code>. reuseIdentifier is part of the cell reusing mechanism of UIKit. We give a cell a identifier that can be used to fetch a used cell instance again to reuse with new cell. This is a String typically the name of the subclass of <code>UITableViewCell</code></p>

<h4 id="useprotocolextensiontogiveadefaultimplementationofreuseidentifer">Use protocol extension to give a default implementation of reuseIdentifer.</h4>

<pre><code class="language-swift">protocol ReusableView: class{}

extension ReusableView where Self: UIView{  
    static var reuseIdentifier: String{
        return String(self)
    }
}
</code></pre>

<p>How cool is that. Let me explain.</p>

<h5 id="reusableviewclass"><code>ReusableView: class</code></h5>

<p>This means the protocol ReusableView is class only protocol. Remember,By default Swift protocol can be implemented by structures and enumerations as well. You can limit a protocol to be implemented by class type only using this.</p>

<h5 id="whereself"><code>where Self:</code></h5>

<p>Self is determined at compile-time, not runtime and represent the class that implement <code>ReusableView</code> protocol.</p>

<h5 id="stringself"><code>String(self)</code></h5>

<p>This is swift equivalent of NSStringFromClass. Get the String value of class name.</p>

<p>We solved it once and for all. </p>

<pre><code class="language-swift">class MyTableCell: UITableViewCell,ReusableView{  
}

MyTableViewCell.reuseIdentifer //"MyTableCell"  
</code></pre>]]></content:encoded></item><item><title><![CDATA[I'm Swift function. I have many faces - Default parameter values]]></title><description><![CDATA[<h2 id="defaultparametervalues">Default Parameter Values</h2>

<p>Swift functions can have default parameter values. This is done by assigning a parameter value after the type.</p>

<pre><code class="language-swift">func show(animated: Bool = true){  
    if (animated){
        //Animation Code
    }
} 
</code></pre>

<p>The best piece is you can omit parameters with default values in function call. Cool.</p>

<pre><code class="language-swift">show() //Same as show(true)</code></pre>]]></description><link>https://swift.madnik.space/im-swift-function-i-have-many-faces-2/</link><guid isPermaLink="false">3c196be4-42e5-496d-a8bc-a7620abeb5ec</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Tue, 28 Jun 2016 11:02:19 GMT</pubDate><content:encoded><![CDATA[<h2 id="defaultparametervalues">Default Parameter Values</h2>

<p>Swift functions can have default parameter values. This is done by assigning a parameter value after the type.</p>

<pre><code class="language-swift">func show(animated: Bool = true){  
    if (animated){
        //Animation Code
    }
} 
</code></pre>

<p>The best piece is you can omit parameters with default values in function call. Cool.</p>

<pre><code class="language-swift">show() //Same as show(true)  
</code></pre>

<p>if you want to call the function with non-default value.</p>

<pre><code class="language-swift">show(false)  
</code></pre>

<p>When it comes to multi parameter functions. <br>
For example:</p>

<pre><code class="language-swift">func start(airConditionOn: Bool = true,lightsOn: Bool = false, headLightsOn: Bool, playMusic: Bool, wiserSpeed: Int = 0){

}
</code></pre>

<p>you can call this method in many possible ways. Many face functions. ðŸ‘»</p>

<pre><code class="language-swift">start(headLightsOn: false, playMusic: false)  
start(lightsOn: false, headLightsOn: true, playMusic: true, wiserSpeed: 3)  
start(false, headLightsOn: true, playMusic: false, wiserSpeed: 2)  
</code></pre>

<p>As you can see this can be confusing sometimes. Apple documentation has recommendation to make this less clutter. </p>

<blockquote>
  <p>Place parameters with default values at the end of a functionâ€™s parameter list. This ensures that all calls to the function use the same order for their nondefault arguments, and makes it clear that the same function is being called in each case.</p>
</blockquote>

<p>i.e</p>

<p>Bring to 2 parameters <strong><code>playMusic</code></strong> and <strong><code>headLightsOn</code></strong> to the front. Because they have to be provided anyway. </p>

<pre><code class="language-swift">func start(playMusic: Bool, headLightsOn: Bool,airConditionOn: Bool = true,lightsOn: Bool = false, wiserSpeed: Int = 0){

}
</code></pre>]]></content:encoded></item><item><title><![CDATA[Some questions about Enums . ??]]></title><description><![CDATA[<p>Check weather you digest the reasons for following enumerations become valid or invalid.</p>

<script src="https://gist.github.com/madnik/143e19f4509772ae418f.js"></script>]]></description><link>https://swift.madnik.space/power-of-enums-in-swift-think/</link><guid isPermaLink="false">aa24ea64-6e2f-4d0a-9b16-c4321e315ff8</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Sun, 26 Jun 2016 09:20:13 GMT</pubDate><content:encoded><![CDATA[<p>Check weather you digest the reasons for following enumerations become valid or invalid.</p>

<script src="https://gist.github.com/madnik/143e19f4509772ae418f.js"></script>]]></content:encoded></item><item><title><![CDATA[Power of Swift Enums - 01]]></title><description><![CDATA[<p>Enumerations in swift are much more flexible than enums in many other programming languages. The highlights of Swift enums are,</p>

<ul>
<li>You do not have to provide a value for each member of the enumeration.</li>
<li>If a value is provided it can be a string, a character, or a value of</li></ul>]]></description><link>https://swift.madnik.space/power-of-swift-enums/</link><guid isPermaLink="false">7332195d-9112-43b0-b09a-0a0b4d581fd1</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Sun, 26 Jun 2016 09:18:21 GMT</pubDate><content:encoded><![CDATA[<p>Enumerations in swift are much more flexible than enums in many other programming languages. The highlights of Swift enums are,</p>

<ul>
<li>You do not have to provide a value for each member of the enumeration.</li>
<li>If a value is provided it can be a string, a character, or a value of any integer or floating-point type.</li>
<li>Members can specify associated value of any type to store along with the member value.</li>
</ul>

<p>Enumeration syntax</p>

<pre><code class="language-swift">enum SwiftEnumeration {  
    //enumeration definition goes here
}
</code></pre>

<p>Example</p>

<pre><code class="language-swift">enum Gender {  
    case Male
    case Female
}
</code></pre>

<p>Unlike ObjectiveC, <code>Male</code>, <code>Female</code> does not implicitly equal to 0,1. Instead they are values in their own right, with an explicitly defined type of <strong>Gender</strong>.</p>

<blockquote>
  <p>Convention: Enumeration names should start with a capital letter. Give enumeration types singular name.</p>
</blockquote>

<p>Members can be defined in a single line using comma separated values.</p>

<pre><code class="language-swift">enum Planet {  
    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
}
</code></pre>

<p><strong>[Snippet and Explain]</strong></p>

<pre><code class="language-swift">var gender = Gender.Male

//Once assigned we can use short hand syntax
gender = .Female  
</code></pre>

<p>The type of <code>gender</code> is inferred to be <code>Gender</code> once initialized with one of the possible values. There after you can use short hand syntax. Type is not necessary.</p>

<h3 id="associatedvalues">Associated Values</h3>

<p>Swift Enumerations can store associated values of other types alongside with member values. </p>

<pre><code class="language-swift">enum Cipher {  
    case md5(NSString)
    case sha1(NSString)
}
</code></pre>

<p>Above code defines a enumeration type called Cipher which can take either a value of Hash of Sha1 with an associated value of type <code>NSString</code>. <br>
The definition doesn't initialize any NSString value. It just defines type of associated value to use with Cipher.</p>

<p>Lets create a Hash Cipher.</p>

<pre><code class="language-swift">var hashcipher = Cipher.md5(""8743b52063cd84097a65d1633f5c74f5"")  
</code></pre>

<h3 id="rawvalues">Raw Values</h3>

<p>As an alternative to associated values enumeration member can come pre-populated defaults values. Those are called raw values and have to of same type. <br>
Lets consider the example in official swift documentation.</p>

<pre><code class="language-swift">enum ASCIIControlCharacter: Character {  
    case Tab = ""\t""
    case LineFeed = ""\n""
    case CarriageReturn = ""\r""
}
</code></pre>

<p>Here raw values of the enumeration called <code>ASCIIControlCharacter</code> are defined to be of type <code>Character</code>. Here are some rules applicable for raw values.</p>

<ul>
<li>Raw value of particular enumeration member have to always same. Unlike associated values.</li>
<li>Each ray value must be unique within enumeration declaration.</li>
<li>Raw value can be of type String, Character, or any of integer, floating-point number types."</li>
</ul>]]></content:encoded></item><item><title><![CDATA[Swift Tuple and Types]]></title><description><![CDATA[<p>Tuple made it into headlines when the swift was announced. Functions got the ability can return multiple values with help of tuples. What is this tuple. <br>
We will look how tuples fit into Swift type system.</p>

<p>Swift type system divided into 2 categories.</p>

<ul>
<li>names types - Types that given a</li></ul>]]></description><link>https://swift.madnik.space/swift-tuple-and-types/</link><guid isPermaLink="false">c3659911-6d9c-43ab-a3c3-102128921690</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Sun, 26 Jun 2016 07:51:09 GMT</pubDate><content:encoded><![CDATA[<p>Tuple made it into headlines when the swift was announced. Functions got the ability can return multiple values with help of tuples. What is this tuple. <br>
We will look how tuples fit into Swift type system.</p>

<p>Swift type system divided into 2 categories.</p>

<ul>
<li>names types - Types that given a name when defined.</li>
<li>compound types - Simply type without names.</li>
</ul>

<p>Tuple is a compound type. For example</p>

<pre><code class="language-swift">(Int, Int)
</code></pre>

<p>Tuple is list of comma separated values, which enclose in parentheses. Tuple can also be contained with zero values. </p>

<pre><code class="language-swift    ">()
</code></pre>

<p>This is an Empty Tuple. <code>Void</code> is a <code>typealias</code> for empty tuple. <br>
Well that is this <code>typealias</code>. </p>

<h1 id="whatistypealias">What is typealias</h1>

<p>Type Alias is a given type name for existing named or compound type in swift. <br>
After defined alias name can be used instead of existing named or compound type.</p>

<pre><code class="language-swift">typealias Point = (Int, Int)  
</code></pre>

<p>In above example <code>Point</code> becomes a aliased type for existing tuple type of <code>(Int, Int)</code>. This is very handy for compound types like tuples.</p>

<h1 id="functionswithmultiplereturnvalues">Functions with Multiple Return Values</h1>

<p>Lets look at an example of function returning multiple values thanks to Tuples.</p>

<pre><code class="language-swift">func getTime() -&gt; (Int, Int, Int) {

    //Calculating Date components. 
    let date = NSDate()
    let calendar = NSCalendar.currentCalendar()
    let components = calendar.components(.CalendarUnitHour | .CalendarUnitMinute | .CalendarUnitSecond, fromDate: date)
    let hours = components.hour
    let minutes = components.minute
    let seconds = components.second

    return ( hours, minutes, seconds)
}
</code></pre>

<p>If you don't understand calculating dates components. Just focus on how to tuple to return multiple values of Hour, Minutes and Seconds. <br>
If you call</p>

<pre><code class="language-swift">let time = getTime()  
</code></pre>

<p>Returns - <code>(.0 18, .1 17, .2 50)</code>. <br>
Values will be different for you as you call this on a different date. <br>
Individual member values of the tuple can be accessed using,</p>

<pre><code class="language-swift">time.0  
time.1  
time.2  
</code></pre>

<p>Member are named using there index of appearance.  What if we want more proper name for elements. <br>
Tuple member values can be named as part of function return type.</p>

<pre><code class="language-swift">func getTime() -&gt; (hours: Int, minutes:  Int, seconds: Int) {  
    ...
    return ( hours, minutes, seconds)
}
</code></pre>

<p>Now the tuple named members can be accessed as follows.</p>

<pre><code class="language-swift">let time = getTime()  
time.hours  
time.minutes  
time.hours  
</code></pre>]]></content:encoded></item><item><title><![CDATA[Lets iterate an swift array while filtering nil elements.]]></title><description><![CDATA[Iterate an swift array skipping nil elements with swift pattern matching power.]]></description><link>https://swift.madnik.space/lets-iterate-an-swift-array-while-filtering-nil-elements/</link><guid isPermaLink="false">6f0542ef-bcf1-4cb0-b956-3078135d93ca</guid><dc:creator><![CDATA[Madushan]]></dc:creator><pubDate>Sun, 26 Jun 2016 07:23:12 GMT</pubDate><content:encoded><![CDATA[<h2 id="anotherpatternmatchingusage">Another Pattern Matching Usage</h2>

<p>Swift <code>Pattern Matching</code> is great. Which enables ton of possibilities which would have ended up in nested branches in <code>ObjectiveC</code></p>

<p>Here is a very simple example of how to iterating an array skipping nil elements in swift.</p>

<pre><code class="language-swift">let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]  
// Match only non-nil values
for case let number? in arrayOfOptionalInts{  
    print("Found a Int : \(number)")
}
</code></pre>

<p>So as you can see this is possible thanks to power of pattern matching. Without such power it would have been something like.</p>

<pre><code class="language-swift">for element in arrayOfOptionalInts{  
    if let int = element{
        print("Foun a Int: \(int)")
    }
}
</code></pre>

<p>It can be even this.</p>

<pre><code class="language-swift">let arrayOfTuples: [(Int?,Int?)] = [(nil,1),(1,3),(nil,nil)]

for case let (x?,y?) in arrayOfTuples{  
    print("Found non nil (Int,Int) Tuple: (\(x),\(y))")
}
</code></pre>]]></content:encoded></item></channel></rss>
